[TOC]

# 第一章：基础

随着你对Rust学习的深入，准确理解基础知识非常重要。Rust和其他语言一样，当你开始使用这个语言的复杂特性时，各种关键词和概念的精确含义变得很重要。在这一章中，我们将浏览Rust的原生类型，并尝试给出它们的清晰定义，它们是如何工作的，以及它们为什么是这样的。尤其是，我们会查看为什么变量和值不同，它们如何在内存中被表示的，以及一个程序有哪些不同的内存区域。然后，我们会讨论一些内容，如所有权，借用，生命周期，以便你继续阅读本书。

你可以顺序阅读本章，或者用作参考，来复习一些感觉不确定的概念。我建议你感觉内容很轻松时再继续进行，因为错误理解原生类型将很快阻挡理解高级话题，或者导致错误使用。

## 讨论内存

不是所有内存都是相同的。在大部分编程环境中，你的程序可以访问栈，堆，寄存器，代码段(text segments)，存储器映射寄存器(memory-mapped register)，内存映射文件（*Memory*-*mapped file*），和非易失性存储器（nonvolatile RAM）。在特定情况下，你选择使用哪个会影响你能存储什么，它能访问多长时间，以及你是用什么机制来访问它。这些内存区域的细节在不同平台不同，超出了本书讨论范围，但一些对于你理解Rust代码很重要，需要进行讨论。

### 内存术语

在深入研究内存区域之前，你需要首先了解值，变量和指针的区别。Rust中的值是一个类型和该类型的值域的一个元素的组合。一个值可以根据类型的_表示法_被转为字节序列，但就其本身而言，你可以认为一个值更像你（一个程序员[?]）。例如类型为u8的数字6，是整数6的一个实例，其_在内存中的表示_是字节0x06。类似，字符串"Hello world"是在字符串域的一个值，其_表示_形式是UTF-8编码。值的含义与这些字节存储的位置无关。

一个值可以被存在一个**位置**，在Rust术语中是“一个可以放一个值的位置”。这个位置可以在栈上，堆上，或者其他很多地方。最常见的放置一个值的地方是**变量**，其为一个栈上的命名的slot。

一个指针是一个值，可以存放一个区域的内存地址，因此，一个指针指向一个位置。指针可以被解引用以访问存储在它所指向的内存位置的值。我们可以在多个变量中存储同一个指针，因此有多个变量间接的指向内存中的同一个位置，从而指向底层的同一个值。

考虑如下的代码1-1，其展示了这三个元素：

---



```rust
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y;
```

---

Listing 1-1: Values, variables, and pointers

这里，有四个不同的值：42（一个i32），43（一个i32），x的地址（一个指针），y的地址（一个指针）。这里也有四个变量：x, y, var1, var2。最后两个变量都存储了指针类型的值，因为引用是指针。虽然var1和var2最初存的是同一个值，但它们存储的是该值的独立副本；当我们改变存储在var2中的值时，存储在var1中的值不变。=运算符将右侧表达式的值存储在左侧命名的地方。

变量，值和指针的区别在下面的一个有趣的例子中显得很重要：

---

```rust
let string = "Hello world";
```

---

尽管我们给变量string分配一个string类型的值，变量的值是指向字符串"Hello world"第一个字符的指针，而不是字符串本身。你可能会说，“等一下，这个string类型的值实际存储在哪？指针指向哪？”如果是这样，你眼光很敏锐--我们马上就会说到这点。

+ 注意：技术上讲，字符串的值还包括字符串的长度。我们将在第二章讨论宽指针类型时讨论这个问题 我们将在第二章讨论宽指针类型时讨论这个问题。

### 深入变量

我先前给出的变量的定义很宽泛，不太可能对所有的都适用。当你碰到更复杂的代码，你需要一个更精确的心智模型帮你推理程序到底在做什么。有很多这样的模型可供我们使用。对它们进行描述可能需要几章内容，也超出了本书的内容，但大致上，它们可以被分为两类：高层模型和低层模型。高层模型在考虑代码的生命周期和借用时很有用，低层模型适合推理unsafe代码和原始指针时使用。在下面两节中描述的变量模型将足以满足本书的大部分材料。

#### 高层模型

在高层模型中，我们不认为变量是存储字节的地方。相反，我们认为它们只是在整个程序中被实例化、移动和使用时赋予数值的名称。当你把值分配给一个变量时，该值就会被该变量命名。当一个变量后来被访问时，你可以想象从该变量以前的访问到新的访问画一条线，这在两个访问之间建立了依赖关系。如果一个变量中的值被移动，就不能再从它那里画线了。

在这个模型中，一个变量只有在它持有合法的值时才会存在；你不能从一个值未被初始化或已经失效的变量上画线。使用这个模型，你的整个程序由许多这样的依赖线组成，通常被称为流，每个流都与一个值的特定实例的生命周期相匹配。流可以分叉和合并当有分支时，每一次分叉都追踪该值的一个不同的生命周期。编译器可以检查在你的程序中的任何给定点，所有可以相互平行存在的流是兼容的。例如，不能有两个并行的流对一个值进行可变的访问。也不可能存在当没有一个拥有该值的流，借用该值的流。清单1-2显示了这两种情况的例子。

---

```rust
let mut x;
// 这里访问是非法的，没有地方可以开始划线
// assert_eq!(x, 42);
x = 42;
// 这里是可以的，可以从上面分配值的地方开始划线
let y = &x;
// 这里从x创建第二个，可变的流
x = 43;
// 
// this continues the flow from y, which in turn draws from x.
// but that flow conflicts with the assignment to x!
assert_eq!(*y, 42);
```

---

Listing 1-2: Illegal flows that the borrow checker will catch



























