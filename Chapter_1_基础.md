[TOC]

# 第一章：基础

随着你对Rust学习的深入，准确理解基础知识非常重要。Rust和其他语言一样，当你开始使用这个语言的复杂特性时，各种关键词和概念的精确含义变得很重要。在这一章中，我们将浏览Rust的原生类型，并尝试给出它们的清晰定义，它们是如何工作的，以及它们为什么是这样的。尤其是，我们会查看为什么变量和值不同，它们如何在内存中被表示的，以及一个程序有哪些不同的内存区域。然后，我们会讨论一些内容，如所有权，借用，生命周期，以便你继续阅读本书。

你可以顺序阅读本章，或者用作参考，来复习一些感觉不确定的概念。我建议你感觉内容很轻松时再继续进行，因为错误理解原生类型将很快阻挡理解高级话题，或者导致错误使用。

## 讨论内存

不是所有内存都是相同的。在大部分编程环境中，你的程序可以访问栈，堆，寄存器，代码段(text segments)，存储器映射寄存器(memory-mapped register)，内存映射文件（*Memory*-*mapped file*），和非易失性存储器（nonvolatile RAM）。在特定情况下，你选择使用哪个会影响你能存储什么，它能访问多长时间，以及你是用什么机制来访问它。这些内存区域的细节在不同平台不同，超出了本书讨论范围，但一些对于你理解Rust代码很重要，需要进行讨论。

### 内存术语

在深入研究内存区域之前，你需要首先了解值，变量和指针的区别。Rust中的值是一个类型和该类型的值域的一个元素的组合。一个值可以根据类型的_表示法_被转为字节序列，但就其本身而言，你可以认为一个值更像你（一个程序员[?]）。例如类型为u8的数字6，是整数6的一个实例，其_在内存中的表示_是字节0x06。类似，字符串"Hello world"是在字符串域的一个值，其_表示_形式是UTF-8编码。值的含义与这些字节存储的位置无关。

一个值可以被存在一个**位置**，在Rust术语中是“一个可以放一个值的位置”。这个位置可以在栈上，堆上，或者其他很多地方。最常见的放置一个值的地方是**变量**，其为一个栈上的命名的slot。

一个指针是一个值，可以存放一个区域的内存地址，因此，一个指针指向一个位置。指针可以被解引用以访问存储在它所指向的内存位置的值。我们可以在多个变量中存储同一个指针，因此有多个变量间接的指向内存中的同一个位置，从而指向底层的同一个值。

考虑如下的代码1-1，其展示了这三个元素：

---



```rust
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y;
```

---

Listing 1-1: Values, variables, and pointers

这里，有四个不同的值：42（一个i32），43（一个i32），x的地址（一个指针），y的地址（一个指针）。这里也有四个变量：x, y, var1, var2。最后两个变量都存储了指针类型的值，因为引用是指针。虽然var1和var2最初存的是同一个值，但它们存储的是该值的独立副本；当我们改变存储在var2中的值时，存储在var1中的值不变。=运算符将右侧表达式的值存储在左侧命名的地方。

变量，值和指针的区别在下面的一个有趣的例子中显得很重要：

---

```rust
let string = "Hello world";
```

---

尽管我们给变量string分配一个string类型的值，变量的值是指向字符串"Hello world"第一个字符的指针，而不是字符串本身。你可能会说，“等一下，这个string类型的值实际存储在哪？指针指向哪？”如果是这样，你眼光很敏锐--我们马上就会说到这点。

+ 注意：技术上讲，字符串的值还包括字符串的长度。我们将在第二章讨论宽指针类型时讨论这个问题 我们将在第二章讨论宽指针类型时讨论这个问题。

### 深入变量

我先前给出的变量的定义很宽泛，不太可能对所有的都适用。当你碰到更复杂的代码，你需要一个更精确的心智模型帮你推理程序到底在做什么。有很多这样的模型可供我们使用。对它们进行描述可能需要几章内容，也超出了本书的内容，但大致上，它们可以被分为两类：高层模型和低层模型。高层模型在考虑代码的生命周期和借用时很有用，低层模型适合推理unsafe代码和原始指针时使用。在下面两节中描述的变量模型将足以满足本书的大部分材料。

#### 高层模型

在高层模型中，我们不认为变量是存储字节的地方。相反，我们认为它们只是在整个程序中被实例化、移动和使用时赋予数值的名称。当你把值分配给一个变量时，该值就会被该变量命名。当一个变量后来被访问时，你可以想象从该变量以前的访问到新的访问画一条线，这在两个访问之间建立了依赖关系。如果一个变量中的值被移动，就不能再从它那里画线了。

在这个模型中，一个变量只有在它持有合法的值时才会存在；你不能从一个值未被初始化或已经失效的变量上画线。使用这个模型，你的整个程序由许多这样的依赖线组成，通常被称为流，每个流都与一个值的特定实例的生命周期相匹配。流可以分叉和合并当有分支时，每一次分叉都追踪该值的一个不同的生命周期。编译器可以检查在你的程序中的任何给定点，所有可以相互平行存在的流是兼容的。例如，不能有两个并行的流对一个值进行可变的访问。也不可能存在当没有一个拥有该值的流，借用该值的流。清单1-2显示了这两种情况的例子。

---

```rust
let mut x;
// 这里访问是非法的，没有地方可以开始划线
// assert_eq!(x, 42);
1. x = 42;
// 这里是可以的，可以从上面分配值的地方开始划线
2. let y = &x;
// 这里从x创建第二个，可变的流
3. x = 43;
// this continues the flow from y, which in turn draws from x.
// but that flow conflicts with the assignment to x!
4. assert_eq!(*y, 42);
```

---

Listing 1-2: Illegal flows that the borrow checker will catch

首先，我们不能在x初始化之前使用它，因为我们没有开始划线的地方。只有对x分配了值之后才能从它开始划线。这个代码有两个流：一个排他性的(&mut)流，从1-3，一个共享的(&)流从1通过2到4。借用检查器检查每个流的顶点，并检查是否有其他不兼容的流存在。在这个例子中，当借用检查其在3检查到排他性的流时，它检查到一个共享的流在4处终止。因为你不能，同时对一个值有排他性的和共享性的使用，借用检查器拒绝这个代码。注意，如果4不存在，代码将会正确编译。共享的流将会在2处终止，当排他性流在3处检查时，没有冲突的流存在。

如果一个变量使用之前的相同的名字被声明，它们依然被认为是不同的变量。这被称为“遮蔽”--后一个变量遮蔽了前一个同名的变量。这个模型与编译器，特别是借用检查器对你的程序进行推理的方式大致吻合，并实际在编译器内部被使用以生成高效的代码。

#### 低层模型

变量名内存位置可能也可能没有存放合法的值。你可以把变量看作值槽。当你分配它时，这个槽被填充，它的旧值（如果有的话）被丢弃和替代。当你访问它时，编译器检查该槽非空，因为那表示该变量未初始化，或者该值没有被移动。一个变量的指针，指向变量后面的内存，并且可以解引用来获得它的值。例如，在语句 let x: usize, 变量x是在栈上的一个内存区域的名字，有空间来存放大小未usize的值，尽管它没有一个定义的值（槽是空的）。如果你给这个变量分配个值，例如 x = 6，这个内存区域则存放着表示值为6的bites。当你分配值时，&x不变。如果你同时声明多个相同名称的变量，它们背后的内存区间并不相同。这个模型与C和C++，以及许多低级语言使用的一样，在你需要推理内存时很有用。

+ 注意：在这个例子中，我们忽略CPU寄存器并将其作为一个优化。在现实中，编译器会使用一个寄存器来支持一个变量而不是一个内存区域，如果该变量不需要内存地址时。

你可能发现其中一个模型与你之前的心智模型相匹配，但是我希望你能存放两个模型。它们都同样有效，而且都是简化的，就像任何有用的心理模型都必须是这样。如果你能从这两个角度考虑代码，你会发现在处理复杂的代码段时要容易得多，并理解为什么它们能或不能 编译并按你的期望工作。

### 内存区域

现在你已经掌握了我们如何提及内存的方法，我们需要谈一谈内存实际上是什么。内存有许多不同的区域，而且 也许令人惊讶的是，并非所有的内存都存储在计算机的DRAM中。你使用哪一部分内存，对你如何 编写代码产生重大影响。就编写Rust代码而言，三个最重要的区域是堆栈、堆和静态内存。

#### 栈

栈是一个内存段，你的程序将其用来作为函数调用的空间。每当一个函数被调用时，就会在栈的顶部分配一块连续的内存，称为帧。栈的底部是主函数的帧，当函数调用其他的额外的帧被推到栈中。一个函数的帧包含了该函数中的所有变量，以及该函数的任何参数。当函数返回时，其栈帧被回收。

构成函数局部变量值的字节不会立即被擦除，但访问它们是不安全的，因为它们可能已被后续函数调用覆盖，其帧与回收的帧重叠。 即使它们没有被覆盖，它们也可能包含非法使用的值，例如在函数返回时移动的值。

栈帧，尤其是它们最终消失的事实，与 Rust 中的生命周期概念密切相关。 在该帧消失后，存储在栈帧中的任何变量都无法访问，因此对它的任何引用都必须具有最多与该帧的生命周期一样长的生命周期。

#### 堆

堆是一个与程序当前调用堆栈无关的内存池。 堆内存中的值一直存在，直到它们被显式释放。 当您希望一个值超过当前函数框架的生命周期时，这很有用。 如果该值是函数的返回值，则调用函数可以在其堆栈上留下一些空间，供被调用函数在返回之前将该值写入该值。 但是，如果您想将该值发送到当前线程可能根本不与其共享堆栈帧的其他线程，则可以将其存储在堆中。

堆允许您显式分配连续的内存段。 当你这样做时，你会得到一个指向该内存段开始的指针。 该内存段是为您保留的，直到您稍后释放它； 这个过程通常被称为释放，在 C 标准库中相应函数的名称之后。 由于函数返回时堆的分配不会消失，因此您可以在一个位置为某个值分配内存，将指向它的指针传递给另一个线程，然后让该线程安全地继续对该值进行操作。 或者，换种说法，当你堆分配内存时，结果指针有一个不受约束的生命周期——它的生命周期是你的程序保持它存活的时间。

Rust 中与堆交互的主要机制是 Box 类型。 当你编写 Box::new(value) 时，该值被放置在堆上，而你得到的（`Box<T>`）是一个指向堆上该值的指针。 当 Box 最终被丢弃时，该内存被释放。

如果您忘记释放堆内存，它将永远存在，您的应用程序最终将耗尽您机器上的所有内存。 这称为内存泄漏，通常是您想要避免的。 但是，在某些情况下，您明确希望泄漏内存。 例如，假设您有一个整个程序都应该能够访问的只读配置。 您可以在堆上分配它并使用 Box::leak 显式泄漏它以获得对它的“静态引用”。

#### 静态内存

静态内存实际上是对位于您的程序编译成的文件中的几个密切相关区域的统称。 当程序执行时，这些区域会自动加载到程序的内存中。 静态内存中的值在程序的整个执行过程中都有效。 程序的静态内存包含程序的二进制代码，通常映射为只读。 当您的程序执行时，它会逐条指令遍历文本段中的二进制代码，并在调用函数时跳转。静态内存还保存您使用 static 关键字声明的变量的内存，以及代码中的某些常量值，如字符串。

特殊生命周期 'static 得名于静态内存区域，它将引用标记为“只要静态内存存在”，直到程序关闭。由于静态变量的内存是在程序启动时分配的，因此对静态内存中变量的引用根据定义是“静态的”，因为它在程序关闭之前不会被释放。 反之则不然——可以有不指向静态内存的“静态引用”——但这个名字仍然合适：一旦你创建了一个具有静态生命周期的引用，它指向的任何东西都可能在静态内存中 与程序的其余部分一样，因为它可以用于您的程序希望的任何时间。

你会比你更频繁地遇到“静态生命周期” 在使用 Rust 时遇到真正的静态内存（例如通过 static 关键字）。这是因为 'static 经常出现在类型参数的 trait bound 中。像 T: 'static 这样的界限表示类型参数 T 能够存活多久，我们将它保留多久，直到并包括程序的剩余执行。本质上，这个界限要求 T 是拥有的和自给自足的，因为它不借用其他（非静态）值，或者它借用的任何东西也是“静态的”，因此会一直存在到程序结束。 'static 作为边界的一个很好的例子是 std::thread::spawn 函数，它创建一个新线程，它要求你传递给它的闭包是 'static。由于新线程可能比当前线程存活时间更长，因此新线程无法引用旧线程堆栈中存储的任何内容。新线程只能引用在其整个生命周期内都存在的值，这可能是程序的剩余持续时间。

+ 注意：您可能想知道 const 与静态有何不同。 const 关键字将以下项声明为常量。 常量项可以在编译时完全计算，任何引用它们的代码都会在编译期间替换为常量的计算值。 常量没有与之关联的内存或其他存储（它不是一个地方）。您可以将常量视为特定值的方便名称。

## 所有权

Rust 的内存模型的中心思想是所有值都有一个所有者——也就是说，只有一个位置（通常是一个作用域）负责最终释放每个值。这是通过借用检查器强制执行的。如果值被移动，例如通过将其分配给新变量、将其推送到向量或将其放在堆上，则该值的所有权将从旧位置移动到新位置。那时，即使构成值的位在技术上仍然存在，您也无法再通过来自原始所有者的变量访问该值。相反，您必须通过引用其新位置的变量来访问移动的值。

## 借用和生命周期

### 内部可变性

### 生命周期

#### 声明周期和借用检查

#### 泛型生命周期























